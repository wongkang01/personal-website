<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mountain Ascent Platforms</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #dbebf0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            user-select: none;
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
            display: block;
        }
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }
        .controls-hint {
            color: #445;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px 20px;
            border-radius: 12px;
            font-size: 0.95rem;
            box-shadow: 0 8px 16px rgba(0,0,0,0.1);
            max-width: 300px;
        }
        .key {
            display: inline-block;
            background: #eee;
            border: 1px solid #ccc;
            border-radius: 4px;
            padding: 2px 6px;
            font-weight: bold;
            font-family: monospace;
            box-shadow: 0 2px 0 #bbb;
        }
        #win-message {
            position: absolute;
            top: 20px;
            right: 20px;
            /* Removed centering transform */
            transform: scale(0);
            transform-origin: top right; /* Animate from the corner */
            background: rgba(255, 255, 255, 0.95);
            padding: 30px 50px;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 20px 40px rgba(0,0,0,0.2);
            transition: transform 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            pointer-events: auto;
            z-index: 10;
        }
        #win-message.visible {
            transform: scale(1);
        }
        #win-message h1 { margin: 0 0 10px 0; color: #2d4c1e; font-size: 1.5rem; }
        #win-message button {
            background: #e63946;
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: 1rem;
            border-radius: 8px;
            cursor: pointer;
            margin-top: 15px;
        }
        #win-message button:hover { background: #c92a37; }
    </style>
    <!-- Import Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div id="canvas-container"></div>
    
    <div id="ui-layer">
        <div class="controls-hint">
            <h3>How to Play</h3>
            <p><span class="key">W</span> / <span class="key">Up</span> : Jump Up</p>
            <p><span class="key">S</span> / <span class="key">Down</span> : Jump Down</p>
            <hr style="border: 0; border-top: 1px solid #ddd; margin: 10px 0;">
            <p><b>Camera:</b> Drag to Rotate, Scroll to Zoom</p>
            <small>Reach the flag at the peak!</small>
        </div>
    </div>

    <div id="win-message">
        <h1>Summit Reached! ðŸš©</h1>
        <p>You conquered the mountain.</p>
        <button id="reset-btn">Play Again</button>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- Configuration ---
        const COLORS = {
            sky: 0xdbebf0,
            sunriseSky: 0xffa07a, // Light salmon
            sunriseFog: 0xffd700, // Gold
            mountainGrass: 0x4CAF50, // Vibrant Green
            mountainSnow: 0xFFFFFF,   // Pure White
            platform: 0xd4b483, // Wood color for platforms
            platformDark: 0x8b5a2b, // Dark wood for supports
            treeDark: 0x2E7D32, 
            treeLight: 0x66BB6A, 
            shirt: 0xe63946,
            skin: 0xffccaa,
            cloud: 0xf0f0f0,
            sunlightStart: 0xfff0dd, // Initial sun light color
            sunlightEnd: 0xffaa00,   // Sunrise peak color (orange)
            hemisphereSky: 0xdbebf0,
            hemisphereGround: 0x4CAF50,
            hemisphereSunriseSky: 0xffe0a0, // Warm sky for hemisphere
            hemisphereSunriseGround: 0xffa07a // Warm ground for hemisphere
        };

        const MOUNTAIN_CONFIG = {
            height: 22,         
            bottomRadius: 14,   
            topRadius: 0.5, 
            platformsPerTurn: 5, 
            turns: 3.0,
            platformSize: { width: 2.2, depth: 1.0, height: 0.2 } 
        };

        // --- State ---
        const playerState = {
            currentPlatformIndex: 0,
            platformPositions: [],
            playerTargetPosition: new THREE.Vector3(),
            playerMoving: false,
            moveStartTime: 0,
            moveDuration: 0.3, 
            hasWon: false,
            movingUp: true,
            sunriseActive: false,
            sunriseProgress: 0 
        };

        let sunMesh; // Reference to the sun object

        // --- Helper Math ---
        const rng = (min, max) => Math.random() * (max - min) + min;

        // --- Scene Setup ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(COLORS.sky);
        scene.fog = new THREE.Fog(COLORS.sky, 20, 70); 

        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(20, 15, 20);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        container.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 5;
        controls.maxDistance = 40;
        controls.maxPolarAngle = Math.PI / 2 - 0.05;
        controls.enablePan = true;

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const sunLight = new THREE.DirectionalLight(COLORS.sunlightStart, 1.2);
        sunLight.position.set(10, 30, 10);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 2048;
        sunLight.shadow.mapSize.height = 2048;
        scene.add(sunLight);

        const hemisphereLight = new THREE.HemisphereLight(
            COLORS.hemisphereSky, // sky color
            COLORS.hemisphereGround, // ground color
            0.5 // intensity
        );
        scene.add(hemisphereLight);

        // --- 1. Procedural Mountain (Solid Cone Style) ---
        function createMountain() {
            const height = MOUNTAIN_CONFIG.height;
            const radius = MOUNTAIN_CONFIG.bottomRadius;
            const segments = 9; 
            
            const geometry = new THREE.ConeGeometry(radius, height, segments, 6);
            
            const posAttribute = geometry.attributes.position;
            const vertex = new THREE.Vector3();

            for (let i = 0; i < posAttribute.count; i++) {
                vertex.fromBufferAttribute(posAttribute, i);
                
                if (vertex.y > -height/2 + 0.5) { 
                    const noise = 0.8; 
                    vertex.x += rng(-noise, noise);
                    vertex.z += rng(-noise, noise);
                    vertex.y += rng(-0.3, 0.3); 
                }
                posAttribute.setXYZ(i, vertex.x, vertex.y, vertex.z);
            }
            
            geometry.computeVertexNormals();

            const nonIndexedGeo = geometry.toNonIndexed(); 
            const pos = nonIndexedGeo.attributes.position;
            const count = pos.count;
            const colors = [];
            
            const colorGrass = new THREE.Color(COLORS.mountainGrass);
            const colorSnow = new THREE.Color(COLORS.mountainSnow);

            for (let i = 0; i < count; i++) {
                const y = pos.getY(i); 
                const hNormalized = (y + height/2) / height; 

                const mixColor = new THREE.Color();
                let snowThreshold = 0.55; 
                let snowFactor = Math.max(0, Math.min(1, (hNormalized - snowThreshold) / (1 - snowThreshold - 0.1))); 

                mixColor.copy(colorGrass);
                mixColor.lerp(colorSnow, snowFactor);
                mixColor.multiplyScalar(rng(0.98, 1.02)); 

                colors.push(mixColor.r, mixColor.g, mixColor.b);
            }

            nonIndexedGeo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            const mat = new THREE.MeshStandardMaterial({ 
                vertexColors: true, 
                flatShading: true,
                roughness: 0.8
            });

            const mesh = new THREE.Mesh(nonIndexedGeo, mat);
            mesh.position.y = height / 2; 
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);
        }

        // --- 2. Objects ---
        function addPlatforms() {
            const totalPlatforms = Math.floor(MOUNTAIN_CONFIG.turns * MOUNTAIN_CONFIG.platformsPerTurn);
            const platformGeo = new THREE.BoxGeometry(
                MOUNTAIN_CONFIG.platformSize.width, 
                MOUNTAIN_CONFIG.platformSize.height, 
                MOUNTAIN_CONFIG.platformSize.depth
            );
            const supportGeo = new THREE.BoxGeometry(0.2, 0.8, 0.2); 

            const platformMat = new THREE.MeshStandardMaterial({ color: COLORS.platform, flatShading: true });
            const supportMat = new THREE.MeshStandardMaterial({ color: COLORS.platformDark, flatShading: true });

            for (let i = 0; i <= totalPlatforms; i++) {
                const t = i / totalPlatforms;
                let angle = t * MOUNTAIN_CONFIG.turns * Math.PI * 2;
                
                angle += rng(-0.2, 0.2); 

                const mountainY = MOUNTAIN_CONFIG.height * t; 
                let currentRadius = MOUNTAIN_CONFIG.bottomRadius * (1 - t) + MOUNTAIN_CONFIG.topRadius * t;
                
                currentRadius += rng(-0.5, 0.5); 

                const group = new THREE.Group();

                const mesh = new THREE.Mesh(platformGeo, platformMat);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                group.add(mesh);

                const support = new THREE.Mesh(supportGeo, supportMat);
                support.position.set(-0.5, -0.5, 0); 
                support.rotation.z = Math.PI / 4; 
                group.add(support);

                const offsetRadius = currentRadius + MOUNTAIN_CONFIG.platformSize.width * 0.15; 
                
                let platformY = mountainY + MOUNTAIN_CONFIG.platformSize.height / 2;
                platformY += rng(-0.1, 0.1); 
                
                group.position.set(Math.cos(angle) * offsetRadius, platformY, Math.sin(angle) * offsetRadius);
                group.rotation.y = angle + Math.PI / 2; 
                
                scene.add(group);

                playerState.platformPositions.push(group.position.clone());
            }
        }

        // --- SUN OBJECT ---
        function createSun() {
            const geometry = new THREE.SphereGeometry(5, 32, 32);
            const material = new THREE.MeshBasicMaterial({ color: 0xffff00 }); // Bright yellow
            sunMesh = new THREE.Mesh(geometry, material);
            
            // Initial position (far back and low)
            sunMesh.position.set(50, -15, -50); 
            scene.add(sunMesh);
        }

        // --- RAIN SYSTEM ---
        function createRain() {
            const particleCount = 1500;
            const geom = new THREE.BufferGeometry();
            const positions = [];
            
            for(let i=0; i<particleCount; i++) {
                positions.push(rng(-30, 30), rng(0, 30), rng(-30, 30));
            }
            
            geom.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            
            const mat = new THREE.PointsMaterial({
                color: 0xaaddff,
                size: 0.15,
                transparent: true,
                opacity: 0.6
            });

            const rainSystem = new THREE.Points(geom, mat);
            scene.add(rainSystem);

            return {
                mesh: rainSystem,
                update: (dt, playerY) => {
                    const positions = rainSystem.geometry.attributes.position.array;
                    
                    for(let i=1; i<positions.length; i+=3) {
                        positions[i] -= 15 * dt; 
                        if (positions[i] < -2) {
                            positions[i] = 30; 
                        }
                    }
                    rainSystem.geometry.attributes.position.needsUpdate = true;

                    const fadeHeight = 12;
                    let opacity = 0.6 * (1 - Math.max(0, Math.min(1, playerY / fadeHeight)));
                    rainSystem.material.opacity = opacity;
                }
            };
        }

        function createEnvironment() {
            const ground = new THREE.Mesh(
                new THREE.CylinderGeometry(30, 30, 2, 32),
                new THREE.MeshStandardMaterial({ color: COLORS.mountainGrass, flatShading: true })
            );
            ground.position.y = -1;
            ground.receiveShadow = true;
            scene.add(ground);

            const treeGeo = new THREE.Group();
            const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.3, 0.8, 5), new THREE.MeshStandardMaterial({ color: 0x5c4033, flatShading: true }));
            trunk.position.y = 0.4;
            trunk.castShadow = true;
            const leaves = new THREE.Mesh(new THREE.ConeGeometry(0.9, 2.2, 5), new THREE.MeshStandardMaterial({ color: COLORS.treeDark, flatShading: true }));
            leaves.position.y = 1.5;
            leaves.castShadow = true;
            treeGeo.add(trunk);
            treeGeo.add(leaves);

            for(let i=0; i<60; i++) {
                const angle = Math.random() * Math.PI * 2;
                const r = rng(16, 28);
                const tree = treeGeo.clone();
                tree.position.set(Math.cos(angle)*r, 0, Math.sin(angle)*r);
                tree.scale.setScalar(rng(0.6, 1.2));
                scene.add(tree);
            }
        }

        function createCloud() {
            const cloudGeo = new THREE.DodecahedronGeometry(1, 0);
            const cloudMat = new THREE.MeshStandardMaterial({ 
                color: COLORS.cloud, 
                flatShading: true,
                transparent: true,
                opacity: 0.9
            });

            const cloudGroup = new THREE.Group();
            const puffs = [
                { x: 0, y: 0, z: 0, s: 1.5 },
                { x: 1.2, y: 0.2, z: 0, s: 1.2 },
                { x: -1.2, y: 0.1, z: 0, s: 1.3 },
                { x: 0.5, y: 0.8, z: 0.5, s: 1.0 },
                { x: -0.5, y: 0.6, z: -0.5, s: 1.1 },
            ];

            puffs.forEach(p => {
                const mesh = new THREE.Mesh(cloudGeo, cloudMat);
                mesh.position.set(p.x, p.y, p.z);
                mesh.scale.set(p.s, p.s, p.s);
                cloudGroup.add(mesh);
            });

            cloudGroup.position.set(rng(-25, 25), rng(25, 35), rng(-25, 25)); 
            scene.add(cloudGroup);
        }

        // --- 3. Character ---
        let characterGroup;
        const charParts = {}; 

        function createCharacter() {
            const group = new THREE.Group();
            const shirtMat = new THREE.MeshStandardMaterial({ color: COLORS.shirt, flatShading: true });
            const skinMat = new THREE.MeshStandardMaterial({ color: COLORS.skin, flatShading: true });
            const pantsMat = new THREE.MeshStandardMaterial({ color: 0x333333, flatShading: true });

            charParts.torso = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.5, 0.25), shirtMat);
            charParts.torso.position.y = 0.75; 
            charParts.torso.castShadow = true;
            group.add(charParts.torso);

            charParts.head = new THREE.Mesh(new THREE.DodecahedronGeometry(0.2), skinMat);
            charParts.head.position.y = 1.15;
            charParts.head.castShadow = true;
            group.add(charParts.head);

            charParts.leftLeg = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.5, 0.12), pantsMat);
            charParts.leftLeg.position.set(-0.1, 0.25, 0);
            charParts.leftLeg.castShadow = true;
            group.add(charParts.leftLeg);

            charParts.rightLeg = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.5, 0.12), pantsMat);
            charParts.rightLeg.position.set(0.1, 0.25, 0);
            charParts.rightLeg.castShadow = true;
            group.add(charParts.rightLeg);

            charParts.leftArm = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.4, 0.1), skinMat);
            charParts.leftArm.position.set(-0.3, 0.7, 0);
            charParts.leftArm.rotation.z = 0.2;
            group.add(charParts.leftArm);

            charParts.rightArm = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.4, 0.1), skinMat);
            charParts.rightArm.position.set(0.3, 0.7, 0);
            charParts.rightArm.rotation.z = -0.2;
            group.add(charParts.rightArm);

            scene.add(group);
            return group;
        }

        function createFlag() {
            const group = new THREE.Group();
            const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 2), new THREE.MeshStandardMaterial({ color: 0x888888 }));
            pole.position.y = 1;
            group.add(pole);
            const flag = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.5, 0.05), new THREE.MeshStandardMaterial({ color: 0xffcc00 }));
            flag.position.set(0.4, 1.5, 0);
            group.add(flag);

            if (playerState.platformPositions.length > 0) {
                const lastPlatformPos = playerState.platformPositions[playerState.platformPositions.length - 1];
                group.position.copy(lastPlatformPos);
                group.position.y += MOUNTAIN_CONFIG.platformSize.height / 2; 
                group.position.x += 0.5; 
            }
            scene.add(group);
        }

        // --- 4. Game Logic ---
        window.addEventListener('keydown', (e) => {
            if (playerState.playerMoving || playerState.hasWon) return;

            if (e.key === 'w' || e.key === 'W' || e.key === 'ArrowUp') {
                if (playerState.currentPlatformIndex < playerState.platformPositions.length - 1) {
                    playerState.currentPlatformIndex++;
                    playerState.movingUp = true;
                    startPlayerMove();
                }
            } else if (e.key === 's' || e.key === 'S' || e.key === 'ArrowDown') {
                if (playerState.currentPlatformIndex > 0) {
                    playerState.currentPlatformIndex--;
                    playerState.movingUp = false;
                    startPlayerMove();
                }
            }
        });
        
        document.getElementById('reset-btn').addEventListener('click', () => {
            playerState.currentPlatformIndex = 0;
            playerState.hasWon = false;
            playerState.playerMoving = false;
            document.getElementById('win-message').classList.remove('visible');
            playerState.sunriseActive = false;
            playerState.sunriseProgress = 0;

            // Reset lighting to initial state
            scene.background.set(COLORS.sky);
            scene.fog.color.set(COLORS.sky);
            sunLight.color.set(COLORS.sunlightStart);
            sunLight.intensity = 1.2;
            sunLight.position.set(10, 30, 10); // Reset sun light pos
            
            // Reset Hemisphere
            hemisphereLight.color.set(COLORS.hemisphereSky);
            hemisphereLight.groundColor.set(COLORS.hemisphereGround);
            hemisphereLight.intensity = 0.5;

            // Reset Sun Mesh
            if (sunMesh) sunMesh.position.set(50, -15, -50);
            
            if (playerState.platformPositions.length > 0) {
                 const startPos = playerState.platformPositions[0];
                 const platformHalfHeight = MOUNTAIN_CONFIG.platformSize.height / 2;
                 characterGroup.position.set(startPos.x, startPos.y + platformHalfHeight, startPos.z);
                 playerState.playerTargetPosition.copy(characterGroup.position);
                 characterGroup.lookAt(0, characterGroup.position.y, 0);
            }
        });

        function startPlayerMove() {
            playerState.playerMoving = true;
            playerState.moveStartTime = clock.getElapsedTime();
            const targetPlatform = playerState.platformPositions[playerState.currentPlatformIndex];
            const platformHalfHeight = MOUNTAIN_CONFIG.platformSize.height / 2;
            
            playerState.playerTargetPosition.set(
                targetPlatform.x, 
                targetPlatform.y + platformHalfHeight, 
                targetPlatform.z
            );
        }

        // --- Init ---
        createMountain();
        addPlatforms();
        createEnvironment();
        characterGroup = createCharacter();
        createFlag();
        for(let i=0; i<3; i++) createCloud(); 
        const rainSystem = createRain(); 
        createSun(); // Create the sun mesh

        if (playerState.platformPositions.length > 0) {
            const startPlatform = playerState.platformPositions[0];
            const platformHalfHeight = MOUNTAIN_CONFIG.platformSize.height / 2;
            
            characterGroup.position.set(
                startPlatform.x, 
                startPlatform.y + platformHalfHeight, 
                startPlatform.z
            );
            playerState.playerTargetPosition.copy(characterGroup.position);
            characterGroup.lookAt(0, characterGroup.position.y, 0); 
        }

        const clock = new THREE.Clock();
        const CHAR_CENTER_OFFSET = 0.75; 

        function updatePlayer() {
            if (playerState.hasWon) return;

            // Sunrise activation logic
            const sunriseStartPlatformIndex = playerState.platformPositions.length - 4;
            if (playerState.currentPlatformIndex >= sunriseStartPlatformIndex && !playerState.hasWon) {
                playerState.sunriseActive = true;
                const platformsInZone = playerState.platformPositions.length - sunriseStartPlatformIndex;
                playerState.sunriseProgress = Math.min(1, (playerState.currentPlatformIndex - sunriseStartPlatformIndex + 1) / platformsInZone);
            } else if (playerState.currentPlatformIndex < sunriseStartPlatformIndex && playerState.sunriseActive) {
                playerState.sunriseProgress = Math.max(0, playerState.sunriseProgress - 0.05); 
                if (playerState.sunriseProgress === 0) {
                    playerState.sunriseActive = false;
                }
            }

            if (playerState.playerMoving) {
                const elapsed = clock.getElapsedTime() - playerState.moveStartTime;
                const progress = Math.min(1, elapsed / playerState.moveDuration);
                
                characterGroup.position.lerpVectors(characterGroup.position, playerState.playerTargetPosition, 0.15);
                characterGroup.position.y += Math.sin(progress * Math.PI) * 0.1;

                let lookAtPos;
                if (playerState.currentPlatformIndex < playerState.platformPositions.length - 1 && playerState.currentPlatformIndex > 0) {
                     let lookAtIdx = playerState.movingUp ? playerState.currentPlatformIndex + 1 : playerState.currentPlatformIndex - 1;
                     lookAtIdx = Math.max(0, Math.min(lookAtIdx, playerState.platformPositions.length - 1));
                     lookAtPos = playerState.platformPositions[lookAtIdx];
                } else {
                     lookAtPos = new THREE.Vector3(0, characterGroup.position.y, 0);
                }
                characterGroup.lookAt(lookAtPos.x, characterGroup.position.y, lookAtPos.z);

                const freq = 20;
                charParts.leftLeg.rotation.x = Math.sin(elapsed * freq) * 0.5;
                charParts.rightLeg.rotation.x = -Math.sin(elapsed * freq) * 0.5;
                charParts.leftArm.rotation.x = -Math.sin(elapsed * freq) * 0.5;
                charParts.rightArm.rotation.x = Math.sin(elapsed * freq) * 0.5;

                if (characterGroup.position.distanceTo(playerState.playerTargetPosition) < 0.1) {
                    playerState.playerMoving = false;
                    characterGroup.position.copy(playerState.playerTargetPosition);
                    
                    if (playerState.currentPlatformIndex === playerState.platformPositions.length - 1) {
                        playerState.hasWon = true;
                        document.getElementById('win-message').classList.add('visible');
                    }
                }
            } else {
                const t = clock.elapsedTime;
                charParts.torso.position.y = CHAR_CENTER_OFFSET + Math.sin(t * 3) * 0.02; 
                charParts.leftLeg.rotation.x = 0;
                charParts.rightLeg.rotation.x = 0;
                charParts.leftArm.rotation.x = 0;
                charParts.rightArm.rotation.x = 0;
            }
        }

        function updateSunrise(dt) {
            if (playerState.sunriseActive || playerState.sunriseProgress > 0) {
                const progress = playerState.sunriseProgress;

                // Sky background color
                scene.background.lerpColors(
                    new THREE.Color(COLORS.sky),
                    new THREE.Color(COLORS.sunriseSky),
                    progress
                );
                // Fog color
                scene.fog.color.lerpColors(
                    new THREE.Color(COLORS.sky),
                    new THREE.Color(COLORS.sunriseFog),
                    progress
                );
                
                // Calculate position values based on progress
                // Sun mesh rises from Y=-15 to Y=35
                const sunY = THREE.MathUtils.lerp(-15, 35, progress);
                const sunX = 50;
                const sunZ = -50;

                // Move Visual Sun
                if (sunMesh) {
                    sunMesh.position.set(sunX, sunY, sunZ);
                }

                // Update Directional Light to follow visual sun
                sunLight.position.set(sunX, sunY, sunZ);

                // Sun light color and intensity
                sunLight.color.lerpColors(
                    new THREE.Color(COLORS.sunlightStart),
                    new THREE.Color(COLORS.sunlightEnd),
                    progress
                );
                sunLight.intensity = THREE.MathUtils.lerp(1.2, 2.0, progress); 

                // Hemisphere Light
                hemisphereLight.color.lerpColors(
                    new THREE.Color(COLORS.hemisphereSky),
                    new THREE.Color(COLORS.hemisphereSunriseSky),
                    progress
                );
                hemisphereLight.groundColor.lerpColors(
                    new THREE.Color(COLORS.hemisphereGround),
                    new THREE.Color(COLORS.hemisphereSunriseGround),
                    progress
                );
                hemisphereLight.intensity = THREE.MathUtils.lerp(0.5, 1.0, progress);
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta();
            
            updatePlayer();
            updateSunrise(dt); 

            if (rainSystem && characterGroup) {
                rainSystem.update(dt, characterGroup.position.y);
            }

            if (characterGroup) {
                const targetPos = new THREE.Vector3().copy(characterGroup.position);
                targetPos.y += 2; 
                controls.target.lerp(targetPos, 0.05);
                controls.update();
            }
            
            renderer.render(scene, camera);
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>